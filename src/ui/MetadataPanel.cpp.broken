#include "MetadataPanel.h"
#include "PhotoMetadata.h"
#include "NotificationManager.h"
#include "ExifToolDaemon.h"
#include <QScrollArea>
#include <QFileInfo>
#include <QDateTime>
#include <QHBoxLayout>
#include <QJsonDocument>
#include <QJsonArray>
#include <QInputDialog>
#include <QMessageBox>
#include <QToolButton>
#include <QFrame>

namespace PhotoGuru {

// ========== CollapsibleGroupBox Implementation ==========

CollapsibleGroupBox::CollapsibleGroupBox(const QString& title, QWidget* parent)
    : QWidget(parent)
    , m_expanded(false)
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    // Toggle button with title
    m_toggleButton = new QPushButton(QString("▶ %1").arg(title), this);
    m_toggleButton->setStyleSheet(R"(
        QPushButton {
            text-align: left;
            padding: 8px;
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 4px;
            font-weight: bold;
        }
        QPushButton:hover { background: #353535; }
    )");
    connect(m_toggleButton, &QPushButton::clicked, this, &CollapsibleGroupBox::toggleExpanded);
    mainLayout->addWidget(m_toggleButton);
    
    // Content widget (initially hidden)
    m_contentWidget = new QWidget(this);
    m_contentWidget->setVisible(false);
    mainLayout->addWidget(m_contentWidget);
}

void CollapsibleGroupBox::setContentLayout(QLayout* layout) {
    m_contentWidget->setLayout(layout);
}

void CollapsibleGroupBox::toggleExpanded() {
    m_expanded = !m_expanded;
    m_contentWidget->setVisible(m_expanded);
    
    QString buttonText = m_toggleButton->text();
    if (m_expanded) {
        buttonText.replace("▶", "▼");
    } else {
        buttonText.replace("▼", "▶");
    }
    m_toggleButton->setText(buttonText);
}

// ========== MetadataFieldWidget Implementation ==========

MetadataFieldWidget::MetadataFieldWidget(const QString& key, const QString& value, 
                                         bool editable, QWidget* parent)
    : QWidget(parent)
    , m_key(key)
    , m_originalValue(value)
    , m_valueEdit(nullptr)
    , m_textEdit(nullptr)
    , m_removeButton(nullptr)
    , m_modified(false)
{
    QHBoxLayout* layout = new QHBoxLayout(this);
    layout->setContentsMargins(0, 2, 0, 2);
    
    // Key label (fixed width for alignment)
    QLabel* keyLabel = new QLabel(key + ":", this);
    keyLabel->setStyleSheet("color: #aaa; font-weight: bold;");
    keyLabel->setMinimumWidth(150);
    keyLabel->setMaximumWidth(150);
    layout->addWidget(keyLabel);
    
    // Determine if we need multiline edit
    m_multiline = value.length() > 100 || value.contains('\n');
    
    if (m_multiline) {
        m_textEdit = new QTextEdit(this);
        m_textEdit->setPlainText(value);
        m_textEdit->setReadOnly(!editable);
        m_textEdit->setMaximumHeight(80);
        connect(m_textEdit, &QTextEdit::textChanged, this, [this]() {
            m_modified = true;
            emit valueChanged(m_key, m_textEdit->toPlainText());
        });
        layout->addWidget(m_textEdit);
    } else {
        m_valueEdit = new QLineEdit(value, this);
        m_valueEdit->setReadOnly(!editable);
        connect(m_valueEdit, &QLineEdit::textChanged, this, [this](const QString& text) {
            m_modified = true;
            emit valueChanged(m_key, text);
        });
        layout->addWidget(m_valueEdit);
    }
    
    // Remove button (only for custom fields in edit mode)
    if (editable && key.startsWith("Custom:")) {
        m_removeButton = new QPushButton("✕", this);
        m_removeButton->setMaximumWidth(30);
        m_removeButton->setStyleSheet("QPushButton { color: #ff6b6b; font-weight: bold; }");
        connect(m_removeButton, &QPushButton::clicked, this, [this]() {
            emit removeRequested(m_key);
        });
        layout->addWidget(m_removeButton);
    }
}

QString MetadataFieldWidget::value() const {
    if (m_textEdit) {
        return m_textEdit->toPlainText();
    } else if (m_valueEdit) {
        return m_valueEdit->text();
    }
    return QString();
}

void MetadataFieldWidget::setValue(const QString& value) {
    if (m_textEdit) {
        m_textEdit->setPlainText(value);
    } else if (m_valueEdit) {
        m_valueEdit->setText(value);
    }
    m_originalValue = value;
    m_modified = false;
}

void MetadataFieldWidget::setEditable(bool editable) {
    if (m_textEdit) {
        m_textEdit->setReadOnly(!editable);
    } else if (m_valueEdit) {
        m_valueEdit->setReadOnly(!editable);
    }
    
    if (m_removeButton) {
        m_removeButton->setVisible(editable);
    }
}

// ========== MetadataPanel Implementation ==========

MetadataPanel::MetadataPanel(QWidget* parent)
    : QWidget(parent)
    , m_isEditing(false)
{
    setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Expanding);
    setupUI();
}

void MetadataPanel::setupUI() {
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(8, 8, 8, 8);
    mainLayout->setSpacing(10);
    
    // Edit button at top
    QHBoxLayout* topLayout = new QHBoxLayout();
    m_editButton = new QPushButton("Edit Metadata", this);
    m_editButton->setStyleSheet(R"(
        QPushButton {
            padding: 8px 16px;
            background: #1f91ff;
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }
        QPushButton:hover { background: #1a7dd9; }
        QPushButton:disabled { background: #555; color: #999; }
    )");
    connect(m_editButton, &QPushButton::clicked, this, [this]() {
        setEditable(true);
    });
    topLayout->addWidget(m_editButton);
    topLayout->addStretch();
    mainLayout->addLayout(topLayout);
    
    // Create tab widget
    m_tabWidget = new QTabWidget(this);
    mainLayout->addWidget(m_tabWidget);
    
    // Create tabs
    setupMetadataTab();
    setupSemanticKeysTab();
    
    // Add tabs in order: Metadata first, Semantic Keys last
    m_tabWidget->addTab(m_metadataTab, "Metadata");
    m_tabWidget->addTab(m_semanticKeysTab, "Semantic Keys");
    m_tabWidget->setCurrentIndex(0);  // Metadata tab active by default
    
    // Save/Cancel buttons
    QHBoxLayout* buttonLayout = new QHBoxLayout();
    
    m_saveButton = new QPushButton("Save Changes", this);
    m_saveButton->setStyleSheet(R"(
        QPushButton {
            padding: 8px 16px;
            background: #28a745;
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }
        QPushButton:hover { background: #218838; }
    )");
    m_saveButton->setVisible(false);
    connect(m_saveButton, &QPushButton::clicked, this, &MetadataPanel::saveMetadata);
    buttonLayout->addWidget(m_saveButton);
    
    m_cancelButton = new QPushButton("Cancel", this);
    m_cancelButton->setStyleSheet(R"(
        QPushButton {
            padding: 8px 16px;
            background: #6c757d;
            border: none;
            border-radius: 4px;
            color: white;
        }
        QPushButton:hover { background: #5a6268; }
    )");
    m_cancelButton->setVisible(false);
    connect(m_cancelButton, &QPushButton::clicked, this, &MetadataPanel::cancelEdit);
    buttonLayout->addWidget(m_cancelButton);
    
    m_addFieldButton = new QPushButton("+ Add Field", this);
    m_addFieldButton->setStyleSheet(R"(
        QPushButton {
            padding: 8px 16px;
            background: #17a2b8;
            border: none;
            border-radius: 4px;
            color: white;
        }
        QPushButton:hover { background: #138496; }
    )");
    m_addFieldButton->setVisible(false);
    connect(m_addFieldButton, &QPushButton::clicked, this, &MetadataPanel::addNewField);
    buttonLayout->addWidget(m_addFieldButton);
    
    buttonLayout->addStretch();
    mainLayout->addLayout(buttonLayout);
}

void MetadataPanel::setupMetadataTab() {
    m_metadataTab = new QWidget();
    QVBoxLayout* tabLayout = new QVBoxLayout(m_metadataTab);
    tabLayout->setContentsMargins(0, 0, 0, 0);
    
    // Scroll area for content
    m_metadataScrollArea = new QScrollArea();
    m_metadataScrollArea->setWidgetResizable(true);
    m_metadataScrollArea->setFrameShape(QFrame::NoFrame);
    
    m_metadataContent = new QWidget();
    m_metadataLayout = new QVBoxLayout(m_metadataContent);
    m_metadataLayout->setSpacing(12);
    
    // File info section (always visible at top)
    QGroupBox* fileGroup = new QGroupBox("File Info");
    QVBoxLayout* fileLayout = new QVBoxLayout(fileGroup);
    m_filenameLabel = new QLabel("No image loaded");
    m_filenameLabel->setWordWrap(true);
    m_filenameLabel->setStyleSheet("color: #aaa;");
    fileLayout->addWidget(m_filenameLabel);
    m_metadataLayout->addWidget(fileGroup);
    
    // Quick Edit Section (commonly used fields)
    QGroupBox* quickEditGroup = new QGroupBox("Quick Edit");
    QVBoxLayout* quickEditLayout = new QVBoxLayout(quickEditGroup);
    
    // Rating
    QHBoxLayout* ratingLayout = new QHBoxLayout();
    ratingLayout->addWidget(new QLabel("Rating:", this));
    m_ratingLabel = new QLabel("☆☆☆☆☆ (0/5)");
    m_ratingLabel->setStyleSheet("font-size: 16px; color: #1f91ff;");
    ratingLayout->addWidget(m_ratingLabel);
    ratingLayout->addStretch();
    quickEditLayout->addLayout(ratingLayout);
    
    m_ratingSlider = new QSlider(Qt::Horizontal, this);
    m_ratingSlider->setRange(0, 5);
    m_ratingSlider->setValue(0);
    m_ratingSlider->setEnabled(false);
    connect(m_ratingSlider, &QSlider::valueChanged, this, &MetadataPanel::updateRatingDisplay);
    quickEditLayout->addWidget(m_ratingSlider);
    
    // Title
    quickEditLayout->addWidget(new QLabel("Title:", this));
    m_titleEdit = new QLineEdit(this);
    m_titleEdit->setPlaceholderText("Enter title...");
    m_titleEdit->setReadOnly(true);
    quickEditLayout->addWidget(m_titleEdit);
    
    // Description
    quickEditLayout->addWidget(new QLabel("Description:", this));
    m_descriptionEdit = new QTextEdit(this);
    m_descriptionEdit->setPlaceholderText("Enter description...");
    m_descriptionEdit->setMaximumHeight(100);
    m_descriptionEdit->setReadOnly(true);
    quickEditLayout->addWidget(m_descriptionEdit);
    
    // Keywords
    quickEditLayout->addWidget(new QLabel("Keywords:", this));
    m_keywordsEdit = new QLineEdit(this);
    m_keywordsEdit->setPlaceholderText("Comma-separated keywords...");
    m_keywordsEdit->setReadOnly(true);
    quickEditLayout->addWidget(m_keywordsEdit);
    
    // Category
    quickEditLayout->addWidget(new QLabel("Category:", this));
    m_categoryEdit = new QLineEdit(this);
    m_categoryEdit->setPlaceholderText("e.g., landscape, portrait...");
    m_categoryEdit->setReadOnly(true);
    quickEditLayout->addWidget(m_categoryEdit);
    
    // Location
    quickEditLayout->addWidget(new QLabel("Location:", this));
    m_locationEdit = new QLineEdit(this);
    m_locationEdit->setPlaceholderText("City, State, Country");
    m_locationEdit->setReadOnly(true);
    quickEditLayout->addWidget(m_locationEdit);
    
    m_metadataLayout->addWidget(quickEditGroup);
    
    // Create collapsible sections for different metadata groups
    m_exifSection = new CollapsibleGroupBox("EXIF Data", this);
    m_metadataLayout->addWidget(m_exifSection);
    
    m_iptcSection = new CollapsibleGroupBox("IPTC Data", this);
    m_metadataLayout->addWidget(m_iptcSection);
    
    m_xmpSection = new CollapsibleGroupBox("XMP Data", this);
    m_metadataLayout->addWidget(m_xmpSection);
    
    m_fileSection = new CollapsibleGroupBox("File Data", this);
    m_metadataLayout->addWidget(m_fileSection);
    
    m_technicalSection = new CollapsibleGroupBox("Quality Analysis", this);
    m_metadataLayout->addWidget(m_technicalSection);
    
    m_customSection = new CollapsibleGroupBox("Custom Fields", this);
    m_metadataLayout->addWidget(m_customSection);
    
    m_metadataLayout->addStretch();
    
    m_metadataScrollArea->setWidget(m_metadataContent);
    tabLayout->addWidget(m_metadataScrollArea);
}

void MetadataPanel::setupSemanticKeysTab() {
    m_semanticKeysTab = new QWidget();
    QVBoxLayout* tabLayout = new QVBoxLayout(m_semanticKeysTab);
    
    m_semanticKeysLabel = new QLabel("No semantic keys data available.\nRun AI analysis to generate semantic keys.");
    m_semanticKeysLabel->setWordWrap(true);
    m_semanticKeysLabel->setStyleSheet("color: #aaa; padding: 20px;");
    m_semanticKeysLabel->setAlignment(Qt::AlignTop | Qt::AlignLeft);
    
    tabLayout->addWidget(m_semanticKeysLabel);
    tabLayout->addStretch();
}

void MetadataPanel::loadMetadata(const QString& filepath) {
    qDebug() << "[MetadataPanel] loadMetadata called for:" << filepath;
    qDebug() << "[MetadataPanel] Current filepath:" << m_currentFilepath;
    
    m_currentFilepath = filepath;
    
    auto metaOpt = MetadataReader::instance().read(filepath);
    
    if (!metaOpt) {
        clear();
        m_filenameLabel->setText(QFileInfo(filepath).fileName() + " (No metadata available)");
        m_editButton->setEnabled(false);
        return;
    }
    
    m_currentMetadata = *metaOpt;
    qDebug() << "[MetadataPanel] Loaded llm_description:" << m_currentMetadata.llm_description;
    displayMetadata(m_currentMetadata);
    m_editButton->setEnabled(true);
}

void MetadataPanel::displayMetadata(const PhotoMetadata& metadata) {
    // Filename
    QFileInfo info(metadata.filepath);
    m_filenameLabel->setText(QString("<b>%1</b><br/><span style='color:#888;'>%2</span>")
        .arg(info.fileName())
        .arg(info.path()));
    
    // Rating
    m_ratingSlider->setValue(metadata.rating);
    updateRatingDisplay(metadata.rating);
    
    // Editable fields
    m_titleEdit->setText(metadata.llm_title);
    m_descriptionEdit->setText(metadata.llm_description);
    m_keywordsEdit->setText(metadata.llm_keywords.join(", "));
    m_categoryEdit->setText(metadata.llm_category);
    m_locationEdit->setText(metadata.location_name);
    
    // EXIF (read-only)
    m_exifLabel->setText(formatExifInfo(metadata));
    
    // Technical (read-only)
    m_technicalLabel->setText(formatTechnicalInfo(metadata.technical));
}

QString MetadataPanel::formatExifInfo(const PhotoMetadata& meta) {
    QStringList parts;
    
    if (!meta.camera_make.isEmpty() || !meta.camera_model.isEmpty()) {
        parts << QString("<b>Camera:</b> %1 %2")
            .arg(meta.camera_make)
            .arg(meta.camera_model);
    }
    
    if (meta.aperture > 0) {
        parts << QString("<b>Aperture:</b> f/%1").arg(meta.aperture, 0, 'f', 1);
    }
    
    if (meta.shutter_speed > 0) {
        parts << QString("<b>Shutter:</b> 1/%1s").arg(static_cast<int>(1.0 / meta.shutter_speed));
    }
    
    if (meta.iso > 0) {
        parts << QString("<b>ISO:</b> %1").arg(meta.iso);
    }
    
    if (meta.focal_length > 0) {
        parts << QString("<b>Focal Length:</b> %1mm").arg(meta.focal_length, 0, 'f', 0);
    }
    
    if (meta.datetime_original.isValid()) {
        parts << QString("<b>Date:</b> %1")
            .arg(meta.datetime_original.toString("yyyy-MM-dd HH:mm:ss"));
    }
    
    return parts.isEmpty() ? "No EXIF data" : parts.join("<br/>");
}

QString MetadataPanel::formatTechnicalInfo(const TechnicalMetadata& tech) {
    QStringList parts;
    
    if (tech.overall_quality > 0) {
        parts << QString("<b>Overall Quality:</b> %1%")
            .arg(static_cast<int>(tech.overall_quality * 100));
    }
    
    if (tech.sharpness_score > 0) {
        parts << QString("<b>Sharpness:</b> %1%")
            .arg(static_cast<int>(tech.sharpness_score * 100));
    }
    
    if (tech.aesthetic_score > 0) {
        parts << QString("<b>Aesthetic:</b> %1%")
            .arg(static_cast<int>(tech.aesthetic_score * 100));
    }
    
    if (tech.face_count > 0) {
        parts << QString("<b>Faces:</b> %1").arg(tech.face_count);
    }
    
    if (tech.blur_detected) {
        parts << "<b style='color:#ff6b6b;'>⚠ Blur detected</b>";
    }
    
    if (tech.is_best_in_burst) {
        parts << "<b style='color:#51cf66;'>✓ Best in burst</b>";
    }
    
    return parts.isEmpty() ? "No analysis data" : parts.join("<br/>");
}

QString MetadataPanel::formatAIAnalysis(const PhotoMetadata& meta) {
    QStringList parts;
    
    if (!meta.llm_title.isEmpty()) {
        parts << QString("<b>Title:</b> %1").arg(meta.llm_title);
    }
    
    if (!meta.llm_description.isEmpty()) {
        parts << QString("<b>Description:</b> %1").arg(meta.llm_description);
    }
    
    if (!meta.llm_keywords.isEmpty()) {
        parts << QString("<b>Keywords:</b> %1").arg(meta.llm_keywords.join(", "));
    }
    
    return parts.isEmpty() ? "Not analyzed yet" : parts.join("<br/>");
}

void MetadataPanel::setEditable(bool editable) {
    m_isEditing = editable;
    
    // Toggle edit mode for fields
    m_ratingSlider->setEnabled(editable);
    m_titleEdit->setReadOnly(!editable);
    m_descriptionEdit->setReadOnly(!editable);
    m_keywordsEdit->setReadOnly(!editable);
    m_categoryEdit->setReadOnly(!editable);
    m_locationEdit->setReadOnly(!editable);
    
    // Toggle buttons
    m_editButton->setVisible(!editable);
    m_saveButton->setVisible(editable);
    m_cancelButton->setVisible(editable);
    
    // Change background color to indicate edit mode
    QString editStyle = editable 
        ? "background: #2a2a2a; border: 1px solid #1f91ff;" 
        : "background: #1e1e1e;";
    
    m_titleEdit->setStyleSheet(editStyle);
    m_descriptionEdit->setStyleSheet(editStyle);
    m_keywordsEdit->setStyleSheet(editStyle);
    m_categoryEdit->setStyleSheet(editStyle);
    m_locationEdit->setStyleSheet(editStyle);
    
    emit editModeChanged(editable);
}

void MetadataPanel::saveMetadata() {
    if (m_currentFilepath.isEmpty()) {
        return;
    }
    
    qDebug() << "[MetadataPanel] BEFORE SAVE - Description:" << m_descriptionEdit->toPlainText().trimmed();
    
    // Update current metadata with edited values
    m_currentMetadata.rating = m_ratingSlider->value();
    m_currentMetadata.llm_title = m_titleEdit->text().trimmed();
    m_currentMetadata.llm_description = m_descriptionEdit->toPlainText().trimmed();
    
    qDebug() << "[MetadataPanel] m_currentMetadata.llm_description:" << m_currentMetadata.llm_description;
    
    QString keywordsText = m_keywordsEdit->text().trimmed();
    if (!keywordsText.isEmpty()) {
        m_currentMetadata.llm_keywords = keywordsText.split(',', Qt::SkipEmptyParts);
        for (QString& kw : m_currentMetadata.llm_keywords) {
            kw = kw.trimmed();
        }
    } else {
        m_currentMetadata.llm_keywords.clear();
    }
    
    m_currentMetadata.llm_category = m_categoryEdit->text().trimmed();
    m_currentMetadata.location_name = m_locationEdit->text().trimmed();
    
    // Save using MetadataWriter
    bool success = MetadataWriter::instance().write(m_currentFilepath, m_currentMetadata);
    
    qDebug() << "[MetadataPanel] Write result:" << success;
    
    if (success) {
        setEditable(false);
        qDebug() << "[MetadataPanel] AFTER SAVE - m_currentMetadata.llm_description:" << m_currentMetadata.llm_description;
        // Don't reload - keep the values we just saved in m_currentMetadata
        // Just emit the signal so other components can update
        emit metadataChanged(m_currentFilepath);
        NotificationManager::instance().showSuccess("Metadata saved successfully! Changes written to XMP/IPTC fields.");
    } else {
        NotificationManager::instance().showError("Failed to save metadata. Make sure the file is writable and ExifTool is installed.");
    }
}

void MetadataPanel::cancelEdit() {
    // Reload original metadata
    displayMetadata(m_currentMetadata);
    setEditable(false);
}

void MetadataPanel::updateRatingDisplay(int rating) {
    QString stars;
    for (int i = 0; i < rating; ++i) {
        stars += "★";
    }
    for (int i = rating; i < 5; ++i) {
        stars += "☆";
    }
    m_ratingLabel->setText(QString("%1 (%2/5)").arg(stars).arg(rating));
}

void MetadataPanel::clear() {
    m_currentFilepath.clear();
    m_filenameLabel->setText("No image loaded");
    m_ratingSlider->setValue(0);
    m_titleEdit->clear();
    m_descriptionEdit->clear();
    m_keywordsEdit->clear();
    m_categoryEdit->clear();
    m_locationEdit->clear();
    m_exifLabel->setText("-");
    m_technicalLabel->setText("-");
    m_editButton->setEnabled(false);
    setEditable(false);
}

} // namespace PhotoGuru
